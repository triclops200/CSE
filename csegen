#!/usr/bin/env ruby 
require "fileutils"
@tmpdir = "/tmp/csedir"
def openfile_p fname,mode
	FileUtils.mkdir_p(@tmpdir+File.dirname(fname))
	return File.open(@tmpdir+fname,mode)
end
headers = "
#include <iostream>
#include <string>
#include <map>
#include <fstream>
#include <cstdlib>
using namespace std;


map<string,string> resolveKeys(char* KeyString) {
    int P = 0;
    map<string,string> KeyMap;
    string Key = \"\";
    string Value = \"\";
    bool Mode = 1; // 0 = key, 1 = value
    while(KeyString[P]) {
        switch(KeyString[P]) {
        case '&':
            KeyMap[Key] = Value;
            Key = \"\";
            Value = \"\";
            Mode = 1;
            break;
        case '=':
            Mode = 0;
            break;
        default:
            if(Mode)
                Key += KeyString[P];
            else
                Value += KeyString[P];
        break;
        }
        P++;
    }
    KeyMap[Key] = Value;
    return KeyMap;
}
bool operator==(const string& lhs, const int& rhs)
{
	return atoi(lhs.c_str())==rhs;
}
bool operator!=(const string& lhs, const int& rhs)
{
	return atoi(lhs.c_str())!=rhs;
}
bool operator>=(const string& lhs, const int& rhs)
{
	return atoi(lhs.c_str())>=rhs;
}
bool operator<=(const string& lhs, const int& rhs)
{
	return atoi(lhs.c_str())<=rhs;
}
bool operator>(const string& lhs, const int& rhs)
{
	return atoi(lhs.c_str())>rhs;
}
bool operator<(const string& lhs, const int& rhs)
{
	return atoi(lhs.c_str())<rhs;
}
string execDir=\"#{File.dirname(ARGV[0])}\";
"
source = ""
source += "int call(map<string,string> Request){"
fname =  ARGV[0]
def old?(finame)
if File.exists?(@tmpdir+finame+".md5")
	res = `md5sum -c #{@tmpdir+finame+".md5"} 2> /dev/null`
	res = res.split(": ")[1]
	if res.strip=="OK"
		return false
	end
	return true
else
	FileUtils.mkdir_p(@tmpdir+File.dirname(finame))
	return true
end
end
contents = File.open(fname,"rb").read
sections = contents.split("<%");
msections = []
sections.each do |o|
	o.split("%>").each do |s|
		msections << s;
	end
end
i=1
if contents.strip[0..1] == "<%"
	i=-1
end
firsttype = i;
cppsections = []
htmlsections = []
msections.each do |s|
	if i == -1
		cppsections << s
	else
		htmlsections << s
	end
	i*=-1
end
i = firsttype;
v = 1
c = 0
xfiles=nil
msections.each do
	begin
		if i == -1
			val = ""
			if cppsections[c][0]=='='
				val = "cout<<"+cppsections[c][1..-1]+";\n"
			elsif cppsections[c][0]=='@'
				xfiles = cppsections[c][1..-1].strip.gsub(" ","").gsub("\n","").gsub("	","").split(",")
			else
				val = cppsections[c]
			end
			source += val
		else 
			source += "cout<<\"" +htmlsections[c].gsub("\"","\\\"").gsub("\n","\\n")+"\";\n";
		end
		if v == 2
			v = 0
			c+=1
		end
		v+=1
	rescue
	end
	i *= -1
end	

source += "}

int main(int argc, char**argv){
	if(argc==2)
	call(resolveKeys(argv[1]));	
	else
	call(resolveKeys(\"\"));
}

"
source = headers + source
f=openfile_p(ARGV[0]+".cpp","w")
f.puts(source)
f.close
wd = (File.dirname(ARGV[0]));
if xfiles
FileUtils.cd(wd)
FileUtils.cp(xfiles,@tmpdir+wd)
else
xfiles=[""]
end
gen = false
if old?(ARGV[0])
	gen = true
end
xfiles.each do |fnm|
	if fnm!=""
		if old?(fnm)
			gen=true
		end
	end
end
if gen
	errmsg = `g++ -O2 #{@tmpdir+ARGV[0]+".cpp"} -I#{@tmpdir+wd} #{xfiles.join" "} -o #{@tmpdir+ARGV[0]+".e"} 2>&1` 
end
if $? == 0
	t =`md5sum #{fname} > #{@tmpdir+fname+".md5"}`
	xfiles.each do |fnm|
		if fnm!=""
			`md5sum #{fnm} > #{@tmpdir+fnm+".md5"}`	
		end
	end
	abort(`#{@tmpdir+ARGV[0]+".e"} #{ARGV[1]}`)
else
	puts "E#{errmsg}"
end

